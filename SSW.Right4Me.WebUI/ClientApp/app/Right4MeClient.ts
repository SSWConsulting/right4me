
// this is file generated by hitting the /swagger/ng2 endpoint
/* tslint: disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v7.0.6156.29525 (NJsonSchema v5.16.6156.29215) (http://NSwag.org)
// </auto-generated>
//----------------------

import 'rxjs/Rx'; 
import {Observable} from 'rxjs/Observable';
import {Injectable, Inject, Optional, OpaqueToken} from '@angular/core';
import {Http, Headers, Response, RequestOptionsArgs} from '@angular/http';

export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

export interface IAccessibilityNeedsClient {
    get(): Observable<AccessibilityNeedVm[]>;
}

@Injectable()
export class AccessibilityNeedsClient implements IAccessibilityNeedsClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    get(): Observable<AccessibilityNeedVm[]> {
        let url_ = this.baseUrl + "/api/AccessibilityNeeds"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processGet(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processGet(response));
                } catch (e) {
                    return <Observable<AccessibilityNeedVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccessibilityNeedVm[]>><any>Observable.throw(response);
        });
    }

    private processGet(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: AccessibilityNeedVm[] = null; 
            result200 = data === "" ? null : <AccessibilityNeedVm[]>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }
}

export interface ILoginClient {
    login(model: LoginVm): Observable<UserProfileVm>;
    testLogin(): Observable<any>;
    logout(): Observable<any>;
}

@Injectable()
export class LoginClient implements ILoginClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    login(model: LoginVm): Observable<UserProfileVm> {
        let url_ = this.baseUrl + "/api/login"; 

        const content_ = JSON.stringify(model);
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processLogin(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processLogin(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<UserProfileVm>><any>Observable.throw(response);
        });
    }

    private processLogin(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: UserProfileVm = null; 
            result200 = data === "" ? null : <UserProfileVm>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }

    testLogin(): Observable<any> {
        let url_ = this.baseUrl + "/api/usercheck"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processTestLogin(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processTestLogin(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<any>><any>Observable.throw(response);
        });
    }

    private processTestLogin(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: any = null; 
            result200 = data === "" ? null : <any>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }

    logout(): Observable<any> {
        let url_ = this.baseUrl + "/api/logout"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processLogout(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processLogout(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<any>><any>Observable.throw(response);
        });
    }

    private processLogout(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: any = null; 
            result200 = data === "" ? null : <any>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }
}

export interface IProductClient {
    get(id: number): Observable<ProductVm>;
    post(model: ProductVm): Observable<any>;
    getByCategory(id: ProductCategory): Observable<ProductVm[]>;
}

@Injectable()
export class ProductClient implements IProductClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    get(id: number): Observable<ProductVm> {
        let url_ = this.baseUrl + "/api/product?"; 

        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processGet(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processGet(response));
                } catch (e) {
                    return <Observable<ProductVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProductVm>><any>Observable.throw(response);
        });
    }

    private processGet(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: ProductVm = null; 
            result200 = data === "" ? null : <ProductVm>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }

    post(model: ProductVm): Observable<any> {
        let url_ = this.baseUrl + "/api/product"; 

        const content_ = JSON.stringify(model);
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processPost(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processPost(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<any>><any>Observable.throw(response);
        });
    }

    private processPost(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: any = null; 
            result200 = data === "" ? null : <any>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }

    getByCategory(id: ProductCategory): Observable<ProductVm[]> {
        let url_ = this.baseUrl + "/api/product/category/{id}"; 

        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processGetByCategory(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processGetByCategory(response));
                } catch (e) {
                    return <Observable<ProductVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProductVm[]>><any>Observable.throw(response);
        });
    }

    private processGetByCategory(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: ProductVm[] = null; 
            result200 = data === "" ? null : <ProductVm[]>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }
}

export interface IRegisterClient {
    register(model: RegisterVm): Observable<any>;
}

@Injectable()
export class RegisterClient implements IRegisterClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    register(model: RegisterVm): Observable<any> {
        let url_ = this.baseUrl + "/api/register"; 

        const content_ = JSON.stringify(model);
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processRegister(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processRegister(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<any>><any>Observable.throw(response);
        });
    }

    private processRegister(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: any = null; 
            result200 = data === "" ? null : <any>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }
}

export interface IReviewClient {
    get(id: number): Observable<ReviewVm>;
    delete(id: number): Observable<void>;
    post(model: ReviewVm): Observable<any>;
}

@Injectable()
export class ReviewClient implements IReviewClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    get(id: number): Observable<ReviewVm> {
        let url_ = this.baseUrl + "/api/Review/{id}"; 

        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processGet(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processGet(response));
                } catch (e) {
                    return <Observable<ReviewVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<ReviewVm>><any>Observable.throw(response);
        });
    }

    private processGet(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: ReviewVm = null; 
            result200 = data === "" ? null : <ReviewVm>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }

    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Review/{id}"; 

        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processDelete(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processDelete(response));
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response);
        });
    }

    private processDelete(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "204") {
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }

    post(model: ReviewVm): Observable<any> {
        let url_ = this.baseUrl + "/api/Review"; 

        const content_ = JSON.stringify(model);
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processPost(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processPost(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<any>><any>Observable.throw(response);
        });
    }

    private processPost(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: any = null; 
            result200 = data === "" ? null : <any>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }
}

export interface ITestEfClient {
    testValues(): Observable<string[]>;
}

@Injectable()
export class TestEfClient implements ITestEfClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    testValues(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/TestEf/TestValues"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processTestValues(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processTestValues(response));
                } catch (e) {
                    return <Observable<string[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<string[]>><any>Observable.throw(response);
        });
    }

    private processTestValues(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: string[] = null; 
            result200 = data === "" ? null : <string[]>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }
}

export interface IUserProfileClient {
    userProfile(): Observable<UserProfileVm>;
    updateUserProfile(model: UserProfileVm): Observable<any>;
}

@Injectable()
export class UserProfileClient implements IUserProfileClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    userProfile(): Observable<UserProfileVm> {
        let url_ = this.baseUrl + "/api/UserProfile"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processUserProfile(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processUserProfile(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<UserProfileVm>><any>Observable.throw(response);
        });
    }

    private processUserProfile(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: UserProfileVm = null; 
            result200 = data === "" ? null : <UserProfileVm>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }

    updateUserProfile(model: UserProfileVm): Observable<any> {
        let url_ = this.baseUrl + "/api/UpdateUserProfile"; 

        const content_ = JSON.stringify(model);
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processUpdateUserProfile(response);
        }).catch((response: any, caught: any) => {
            if (response instanceof Response) {
                try {
                    return Observable.of(this.processUpdateUserProfile(response));
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(response);
                }
            } else
                return <Observable<any>><any>Observable.throw(response);
        });
    }

    private processUpdateUserProfile(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: any = null; 
            result200 = data === "" ? null : <any>JSON.parse(data, this.jsonParseReviver);
            return result200; 
        }
        else
        {
            throw new Error("error_no_callback_for_the_received_http_status"); 
        }
    }
}

export interface AccessibilityNeedVm {
    id: number;
    name: string;
}

export interface LoginVm {
    userName: string;
    password: string;
}

export interface UserProfileVm {
    firstName: string;
    lastName: string;
    email: string;
    userName: string;
    accessibilityNeeds: AccessibilityNeedVm[];
}

export interface ProductVm {
    id: number;
    title: string;
    description: string;
    image: string;
    url: string;
    category: ProductCategory;
    accessibilityReviews: AccessibilityReviewVm[];
    reviews: ReviewVm[];
}

export enum ProductCategory {
    Clothes = 1, 
    Technology = 2, 
    Furniture = 3, 
}

export interface AccessibilityReviewVm {
    id: number;
    accessibilityNeedId: number;
    accessibilityNeed: string;
    rating: number;
}

export interface ReviewVm {
    id: number;
    description: string;
    rating: number;
    productId: number;
    productName: string;
    userId: string;
    userEmail: string;
    userName: string;
    accessibilityReviews: AccessibilityReviewVm[];
}

export interface RegisterVm {
    userName: string;
    password: string;
    confirmPassword: string;
    email: string;
    firstName: string;
    lastName: string;
}